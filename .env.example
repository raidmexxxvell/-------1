# Пример файлa переменных окружения для локального запуска
# Скопируйте этот файл в .env и поправьте значения по необходимости

# DATABASE_URL
# Строка подключения к базе данных. Для локальной разработки удобно использовать SQLite:
#   sqlite:///data/dev.db
# Для production/удалённой БД используйте формат PostgreSQL:
#   postgresql://user:password@host:port/dbname
#
# Примечание: в репозитории может быть указан внешний PostgreSQL (render.com). Для локальной работы
# безопаснее заменить на SQLite или локальный Postgres.
DATABASE_URL=postgresql://post_obn_user:6xCLVopuXICaFjWOptYzFHobrAKUfec7@dpg-d32m6cjipnbc73dalpe0-a.frankfurt-postgres.render.com/post_obn

# Flask / запуск
# FLASK_ENV: development | production | testing
FLASK_ENV=development
# Порт для запуска приложения
PORT=5000
# Режим отладки (1/0)
FLASK_DEBUG=1

# ------------------------- WebSocket (Socket.IO) -------------------------
# WEBSOCKETS_ENABLED
#  - 1 / true  — пробует инициализировать Flask-SocketIO и включить WebSocket/real-time
#  - 0 / false — WebSocket подсистема отключена (только HTTP)
# Откуда брать: если вы хотите real-time обновления в браузере включите 1.
# Также установите соответствующие библиотеки (см. ниже).
WEBSOCKETS_ENABLED=1

# WS_TOPIC_SUBSCRIPTIONS_ENABLED
#  - 1 / true  — включает логику topic-based подписок (в приложении: топики для матчей, пользователей и т.п.)
#  - 0 / false — подписки по темам отключены
WS_TOPIC_SUBSCRIPTIONS_ENABLED=1

# WS_TOPIC_SCHEME
#  - Управляет схемой генерации имён топиков: 'no_date' (по умолчанию) или 'with_date'
#  - Оставьте пустым для значения по умолчанию или установите 'with_date', если хотите включать дату в тему
WS_TOPIC_SCHEME=no_date

# ------------------------- Message queue / Redis -------------------------
# REDIS_URL
#  - Redis часто используется как брокер/хранилище для масштабируемых SocketIO-сервисов или для кэша.
#  - Примеры:
#      локально: redis://localhost:6379/0
#      Docker: redis://redis:6379/0
#      облачный (RedisLabs/Upstash): redis://:<password>@<host>:<port>
#  - Если у вас простой однопроцессный dev-сервер, Redis необязателен, но для нескольких воркеров
#    или использования message_queue в Flask-SocketIO настройка REDIS_URL обязательна.
REDIS_URL=redis://red-d2jlunjipnbc73bbolo0:6379

# ------------------------- Socket.IO / engine
# Для корректной работы WebSocket (Socket.IO) рекомендуется установить один из асинхронных движков:
#   pip install flask-socketio python-socketio eventlet
# либо
#   pip install flask-socketio python-socketio gevent gevent-websocket
#
# Важно:
#  - eventlet проще для локальной разработки: достаточно `pip install eventlet` и `WEBSOCKETS_ENABLED=1`.
#  - Если вы используете несколько процессов/воркеров, укажите REDIS_URL и настройте message_queue в коде.

# ------------------------- Прочие переменные
# BOT_TOKEN и ADMIN_USER_ID — нужны для интеграции с Telegram (если используете бота). Отсюда брать
#   BOT_TOKEN — у BotFather в Telegram (если нет — оставьте пустым на локале).
#   ADMIN_USER_ID — ваш Telegram ID для доступа к админ-эндпойнтам.
BOT_TOKEN=8200009547:AAHRBrY3D-ZyYnsruNZRqtg3A0Z0uy46J7g
ADMIN_USER_ID=515650034

# SECRET_KEY — секрет для сессий/CSRF. Если пустой, будет сгенерирован автоматически при старте.
SECRET_KEY=1234567890abcdef

# ------------------------- Короткие шаги чтобы включить WebSocket локально
# 1) Установите зависимости: pip install -r requirements.txt
#    если хотите использовать eventlet: pip install eventlet
#    либо: pip install gevent gevent-websocket
# 2) В .env установите:
#       WEBSOCKETS_ENABLED=1
#       (при необходимости) REDIS_URL=redis://localhost:6379/0
# 3) Запустите сервер: .\start-local.ps1  (или python run.py)
# 4) В браузере frontend должен подключаться к Socket.IO (обычно через /socket.io)
#
# Если нужно, могу добавить пример docker-compose.yml с Redis + Postgres и инструкцией для запуска.

